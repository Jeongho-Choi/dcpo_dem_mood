---
output: 
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    toc: FALSE
    latex_engine: xelatex
    
title: "Democracy, Public Support, and Measurement Uncertainty"
thanks: "The authors contributed equally to this work.  Corresponding author: [yuehu@mail.tsinghua.edu.cn](mailto:yuehu@mail.tsinghua.edu.cn).  Current version: `r format(Sys.time(), '%B %d, %Y')`."

# author:
# - name: Yuehong 'Cassandra' Tai
#   affiliation: University of Iowa
# - name: Yue Hu
#   affiliation: Tsinghua University
# - name: Frederick Solt
#   affiliation: University of Iowa
  
abstract: "Do democratic regimes depend on public support to avoid backsliding? Does public support, in turn, respond thermostatically to changes in democracy? Two prominent recent studies (Claassen 2020a, 2020b) reinvigorated the classic hypothesis on the positive relationship between public support for democracy and regime survival---and challenged its reciprocal counterpart---by using a latent variable approach to measure mass democratic support from cross-national survey data. But such approaches come with concomitant measurement uncertainty, and neither study incorporated this uncertainty into its analyses. In this letter, we correctly take this uncertainty in account and show that there is no support for the conclusion of either study. We then work to minimize the measurement uncertainty in public support by bringing additional survey data and a superior model of public opinion. Even with these improvements, however, our analyses fail to yield evidence in support of either hypothesis, underscoring the necessity of accounting for measurement uncertainty. [149/150 words]"
keywords: "Democratization, public support, regime survival, measurement uncertainty, IRT."

date: "`r format(Sys.time(), '%B %d, %Y')`"
editor_options: 
  markdown: 
    wrap: sentence
tables: true # enable longtable and booktabs
citation_package: natbib
fontsize: 11pt
linestretch: 1.5 # double spacing using linestretch 1.5
bibliography: dcpo_demsupport.bib
# bibliography: \dummy{`r file.path(getwd(), list.files(getwd(), ".bib$", recursive = TRUE))`}
# csl: https://raw.githubusercontent.com/citation-style-language/styles/master/american-political-science-association.csl
biblio-style: apsr
citecolor: black
linkcolor: black
endnote: no
header-includes:
      - \usepackage{array}
      - \usepackage{caption}
      - \usepackage{graphicx}
      - \usepackage{siunitx}
      - \usepackage{colortbl}
      - \usepackage{multirow}
      - \usepackage{hhline}
      - \usepackage{calc}
      - \usepackage{tabularx}
      - \usepackage{threeparttable}
      - \usepackage{wrapfig}
      - \usepackage{fullpage}
      - \usepackage{pdflscape} #\usepackage{lscape} better for printing, page displayed vertically, content in landscape mode, \usepackage{pdflscape} better for screen, page displayed horizontally, content in landscape mode
      - \newcommand{\blandscape}{\begin{landscape}}
      - \newcommand{\elandscape}{\end{landscape}}
---

(Word count: 3628)

It has long been argued that democratic regimes and public support for them are mutually reinforcing: that high levels of public support ensure democracies remain strong, and that experience with democratic governance generates robust public support [see, e.g., @lipset_social_1959; @Easton1965].
But the evidence for either part of this claim has been decidedly mixed.
Countries with greater democratic support have been found to become stronger and more stable democracies [e.g., @Inglehart2005, pp. 251-254] and just the opposite [@Fails2010, pp. 182-183].
Similarly, studies have alternately found that more experience with democracy yields more democratic support [e.g., @Fails2010, p. 183; @Wuttke2020a, pp. 5-6] or instead that long-established democracies are suffering from democratic fatigue [e.g., @Denemark2016; @Foa2017].

One important reason for these mixed results is the difficulty in measuring democratic support over time and across many countries.
Public support for democracy cannot be directly observed, and its incorrect measurement will limit inferences about the relationships between public opinion and institutional development.
Further, the survey data available across countries and over time on support for democracy---or indeed most topics in public opinion---are sparse and incomparable, greatly hindering broadly comparative research.
Recently, a few pioneering studies have sought to overcome the hurdle of sparse and incomparable data by developing latent variable measurement models of public opinion [see @Caughey2019; @Claassen2019; @Solt2020a].
A pair of prominent recent works took advantage of this latent variable approach to measure democratic support for over one hundred countries for up to nearly three decades and to then assess, respectively, its consequences for and roots in democratic change [@Claassen2020a; @Claassen2020b].
These works concluded, first and supporting the classic argument, that mass support had a positive impact on democratic change, especially the endurance of democracy [@Claassen2020a, pp. 127-130], and, second and directly contrary to it, democratic change has a thermostatic effect on public support, that is that, rather than generating its own support, deepening democracy provokes a backlash and it is instead democratic backsliding that calls forth greater public support [@Claassen2020b, 46-50].

The models employed in these studies' analyses, though, do not account for uncertainty in their measurement of democratic support.
Measurement error challenges statistical analyses, especially when it is correlated with an outcome variable which is the case of democratic support, but it is often ignored in the analysis [@Blackwell2017; @Blackwell2017a].
Because they are unobserved, latent variables are inherently accompanied by measurement uncertainty.
To leave this uncertainty unacknowledged is to make the implausible assumption that the latent variables are measured perfectly, an assumption which distorts both statistical and substantive inference [see, e.g., @Crabtree2015; @juhl_measurement_2019].

In this letter, we reexamine the classic arguments about support for democracy and democratic change tested in these two pieces while correcting this oversight.
In addition to incorporating the measurement uncertainty, we also sought to reduce it by expanding survey data to including 144 countries for up to 33 years between 1988 and 2020 (based on 26% more questions and 33% more survey sources).
Our analyses reveal that the significant relationships between public support and democratic change disappear once measurement uncertainty is taken into account, both in replications with the studies' original data and with expanded data.
That is, once measurement uncertainty is accounted for, there is no empirical support for either claim put forward in these two works: declining democratic support does not signal subsequent democratic backsliding, and changes in democracy do not spur a thermostatic response in democratic support.
  
There are many plausible explanations for these null results, both methodological and theoretical.
Methodologically, one possible issue is that support for democracy is multidimensional, and the survey questions used to measure it simply do not capture all of the dimensions relevant to democratic change, such as commitments to political equality and freedom of expression [see @Schedler2007; @Wuttke2020].
Another is that the relationships among these survey items have varied substantially over time [see @Wuttke2021]; this would violate the assumptions of the public opinion models used and would yield faulty estimates of democratic support.
A third is that these survey questions do not ask respondents how they prioritize democracy relative to other values with which it may come into conflict, such as their partisanship, and so miss capturing the true extent of support democracy would find among the public when public support was actually needed [see @Carey2020; @graham_democracy_2020; @McCoy2020].

From a theoretical perspective, the effect of democracy on public support may depend not on its mere existence but on its effectiveness [see @Magalhaes2014] and particularly with regard to redistribution [see @Krieckhaus2014].
Similarly, the impact of public support on democracy may depend on the extent to which those who support democracy are also dissatisfied with the current regime's performance; that is, that it is not democratic support that is important to democratic change, but rather unsatisfied democratic demand [see @Qi2011].
Culturally, whether the public democratic support has a pro-democratic or anti-authoritarian effect is bounded by emancipative value that, as a belief-anchored orientation, shapes the public's understanding of democracy [see @Brunkert2019; @Kirsch2019; @Kruse2019].
Of course, it could in fact be that democratic change does not actually depend on public opinion of any sort at all but instead is an elite-driven phenomenon [see, e.g., @levitsky_how_2018].

We draw two conclusions, one methodological and one substantive.
As latent variable measurement models become more commonly used, it is absolutely necessary for researchers employing them to incorporate the associated uncertainty into analyses.
And, at a time when democracy is seen as under threat around the world [e.g., @Diamond2015], taken together, Claassen [-@Claassen2020a; -@Claassen2020b] send what is ultimately a reassuring message: the fate of democracy rests with us, the public, and when democratic institutions are undermined, we will swing to their support and constitute "an obstacle to democratic backsliding" [@Claassen2020b, p. 51].
Both of these assertions may well be true, but the evidence we have, properly assessed, does not provide support for them.
There is no room for complacency.


```{r setup, include=FALSE}
options(tinytex.verbose = TRUE)

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  eval = FALSE,
  dpi = 300
)

# If you haven't install `DCPOtools`
# remotes::install_github("fsolt/DCPOtools")

if (!require(pacman)) install.packages("pacman")
library(pacman)

# load all the packages you will use below 
p_load(
  # data scrapping
  dataverse, 
  osfr,
  DCPOtools,
  mitools,
  boot, 
  here,
  # analysis
  plm, 
  rstan, 
  # presentation
  flextable, 
  broomExtra, 
  kableExtra, 
  modelsummary, 
  gridExtra,
  latex2exp,
  drhutools,
  dotwhisker, 
  # data wrangling
  tidyverse, 
  janitor, 
  glue, 
  qs
) 

# Functions preload
set.seed(313)

source(here("R", "tidy_pgmm.r"))
source(here("R", "moc_function.R")) 
source(here("R", "moc_summary.R")) 
source(here("R", "customFunctions.R"))

# Theme setup
theme_set(theme_minimal())

# Data input

supdem <- read.csv(here("data", "Support_democracy_ajps.csv"))
sd.plm <- pdata.frame(supdem, index = c("Country", "Year")) 

# Removed the comments for the final replication file
## Claasseen and extend data
# 
# osf_retrieve_file("hczmf") %>%
#     osf_download(path = "../data")
# 
# osf_retrieve_file("wbu6m") %>%
#     osf_download(path = "../data")
# 
# osf_retrieve_file("2jhbc") %>%
#     osf_download(path = "../data")
# 
# osf_retrieve_file("u96m8") %>%
#     osf_download(path = "../data", conflicts = "overwrite")

load(here("data", "pure_cls_ajps.rda")) 
load(here("data", "pure_cls_apsr.rda")) 
load(here("data", "exp_cls_ajps.rda"))
load(here("data", "exp_cls_apsr.rda")) 

result_clsAJPS <- readRDS(here("output", "estimates_clsMeanAJPS.RDS"))
result_pureAJPS <- readRDS(here("output", "estimates_clsPureAJPS.RDS"))
result_expAJPS <- readRDS(here("output", "estimates_clsExpAJPS.RDS"))

result_clsAPSR <- readRDS(here("output", "estimates_clsMeanAPSR.RDS"))
result_pureAPSR <- readRDS(here("output", "estimates_clsPureAPSR.RDS"))
result_expAPSR <- readRDS(here("output", "estimates_clsExpAPSR.RDS"))

mocresult_pureAJPS <- readRDS(here("output", "estimates_moc_pureAJPS.RDS"))
mocresult_expAJPS <- readRDS(here("output", "estimates_moc_expAJPS.RDS"))
mocresult_pureAPSR <- readRDS(here("output", "estimates_moc_pureAPSR.RDS"))
mocresult_expAPSR <- readRDS(here("output", "estimates_moc_expAPSR.RDS"))

```

# Method

We proceed in three steps.
First, we reproduce the original analyses of Claassen [-@Claassen2020a; -@Claassen2020b], which included only the point estimates of the latent variable of democratic support and so exclude its measurement uncertainty.
Second, we collect the original cross-national survey data, replicate the latent variable measure of democratic support used in the two articles, and conduct the articles' analyses again, this time maintaining the entire distribution of estimates of democratic support in each country-year.
As the third step, we collect even more survey data---increasing these source data by one-fourth---and re-estimate the two articles' analyses once more, again maintaining the full distribution of estimates to preserve measurement uncertainty.


## Incorporating Uncertainty

Although measurement uncertainty has yet attracted attention in the field of comparative public opinion [see, in addition to the works examined here, @OGrady2019], latent variables are estimated with a quantifiable amount of measurement uncertainty, and ignoring that uncertainty in analyses can bias coefficient estimates and standard errors.
Especially when measurement error is correlated with the outcome variable, the resulting bias could either attenuate or exaggerate the magnitude of the estimated effects [see, e.g., @Blackwell2017, p.360; @caughey_policy_2018, p.254].
In light of this, recent studies measuring other latent variables have recommended incorporating their measurement uncertainty in analyses [see @solis_measuring_2020, p. 18; @Gandhi2020, p. 1553], and research examining the consequences of public opinion in the United States has done so [see, e.g., @Kastellec2015, pp. 791-792; @caughey_policy_2018, p. 254]. 

Following this line, after replicating the original analyses with point estimates, we take the distribution of the latent variable, the dependent variable, and control variables to account for the uncertainty from the measurement model as well as dependent and control variables.
To do this, we take 900 draws from the distribution of public democratic support and corruption index, duplicate each article's analysis dataset of variables without “measurement error” 900 times, and assign them to each a different random draw from the posterior distribution of democracy indices.
We estimate each analysis model repeatedly on its respective collection of the datasets, and then make inferences from the distribution of parameter estimates by accounting for both within model standard error and between model variance.
This combine rule was set out in @Rubin1987 and employed in research of measurement errors [see, e.g., @Schnakenberg2014; @Crabtree2015].
@Blackwell2017a's multiple overimputation (MO) uses the same logic to correct sampling variance.
We also employ one alternative technique known as “method of composition” (MOC)  [@treier_democracy_2008, p. 215] as a robustness check [see the Online Supplementary Material \@ref(moc)].


```{r compare_n, eval = TRUE}
dcpo_input_raw1 <-
    read_csv(here::here("data", "dcpo_input_raw.csv"), col_types = "cdcddcd") %>%
    filter(!(
        str_detect(survey, "army_wvs") &
            # WVS obs identified as problematic by Claassen
            ((country == "Albania" & year == 1998) |
                 (country == "Indonesia" &
                      (year == 2001 | year == 2006)) |
                 (country == "Iran" & year == 2000) |
                 (country == "Pakistan" &
                      (year == 1997 | year == 2001)) | # 1996 in Claassen
                 (country == "Vietnam" & year == 2001)
            ) |
            (str_detect(item, "strong_wvs") &
                 ((country == "Egypt" & year == 2012) |
                      (country == "Iran" &
                           (year == 2000 | year == 2007)) | # 2005 in Claassen
                      (country == "India") |
                      (country == "Pakistan" &
                           (year == 1997 | year == 2001)) | # 1996 in Claassen
                      (country == "Kyrgyzstan" &
                           (year == 2003 | year == 2011)) |
                      (country == "Romania" &
                           (year == 1998 | year == 2005 | year == 2012)) |
                      (country == "Vietnam" & year == 2001)
                 )) |
            (
                country %in% c(
                    "Puerto Rico",
                    "Northern Ireland",
                    "SrpSka Republic",
                    "Hong Kong SAR China"
                )
            )
    )) %>%
    DCPOtools::with_min_yrs(2)

# if (!file.exists(here::here("data", "supdem raw survey marginals.tab"))) {
#   dataverse::get_file("supdem raw survey marginals.tab", "doi:10.7910/DVN/HWLW0J") %>% 
#     read_csv(col_types = "cdcddcdc") %>% 
#     write_csv("data/supdem raw survey marginals.tab")
# }

supdem <- read_csv(here::here("data", "supdem raw survey marginals.tab"),
                   col_types = "cdcddcdc") %>% 
  janitor::clean_names() %>% 
  DCPOtools::with_min_yrs(2)

supdem_ncy <- supdem %>%
  dplyr::select(country, year) %>% 
  distinct() %>% 
  nrow()

supdem_surv <- supdem %>%
  dplyr::select(country, year, project) %>%
  distinct() %>%
  nrow()

supdem_ncyi <- supdem %>%
  dplyr::select(country, year, item) %>% 
  distinct() %>% 
  nrow()

dcpo_input_nc <- dcpo_input_raw1 %>% 
  dplyr::select(country) %>% 
  distinct() %>% 
  nrow()

dcpo_input_surv <- dcpo_input_raw1 %>%
  dplyr::select(country, year, survey) %>%
  distinct() %>%
  separate(survey, c("surv1", "surv2"), sep=",", fill = "left") %>%
  pivot_longer(cols = starts_with("surv")) %>%
  filter(!is.na(value)) %>% 
  nrow()

dcpo_input_ncy <- dcpo_input_raw1 %>% 
  dplyr::select(country, year) %>% 
  distinct() %>% 
  nrow()

dcpo_input_ncyi <- dcpo_input_raw1 %>% 
  dplyr::select(country, year, item, survey) %>% 
  distinct() %>% 
  separate(survey, c("surv1", "surv2"), sep=",", fill = "left") %>%
  pivot_longer(cols = starts_with("surv")) %>%
  filter(!is.na(value)) %>% 
  nrow()

increase_cy <- sprintf("%2.1f", (dcpo_input_ncy/supdem_ncy - 1) * 100, 1)
increase_cyi <- sprintf("%2.1f", (dcpo_input_ncyi/supdem_ncyi - 1) * 100, 1)
increase_surv <- sprintf("%2.1f", (dcpo_input_surv/supdem_surv - 1) * 100, 1)
```


In addition to incorporating uncertainty, we also assembled as much available data on democratic support as possible. 
We employed `r dcpo_input_ncyi` national opinions on democracy from `r dcpo_input_surv` national surveys, representing a `r increase_cyi`% and `r increase_surv`% increase respectively over the `r supdem_ncy` opinions and `r supdem_surv` national surveys used in Claassen [-@Claassen2020a; -@Claassen2020b].^[These figures represent the survey data actually used in estimating public support for democracy; as in Claassen [-@Claassen2020a; -@Claassen2020b], countries for which two separate years of survey data were not available were excluded.]

A noteworthy point is that in addition to account for uncertainty in latent variable estimates, we also include the measurement uncertainty in democracy indices and corruption index. 
We extracted the posterior distributions of democratic indices, including Liberal Democracy,  polyarchy, and electoral democracy index, which are provided by [@coppedge2018]. 
We drew 900 samples from the distribution of the Corruption Perception Index.^[Since Corruption Perception Index does not provide standard error before 2011, we imputed the missing standard error using the  multiplication of a country's corruption index and the ratio of its available maximum standard error to its corresponding index.] 

# Results

Figure \@ref(fig:plot-mainAJPS) presents the reanalyses of the hypothesis that public support influences the level of democracy, with democratic support pooled for all countries [@Claassen2020a, Model 1] in the left panel and separated by regime type (Model 2) on the right.
The uppermost set of results replicate @Claassen2020a without uncertainty.
The middle results introduce the uncertainty in the measurement of public support into the model.
The lowermost set presents the results estimated with the expanded data. 


In comparison to the original result, the positive coefficients for democratic support in both model accounting for the uncertainty are no longer statistically significant.
This result is robust when using separated regime types in the explanatory variable. 
The estimation based on MOC yields mixed results.
In pooled OLS models, the public support estimated from the originial data with uncertainty is significant for the whole data and split databut the support estimated from the expanded data is not.
In system GMM models which are more appropriate in this case than pooled OLS models, public support estimated from the original data reached the threshold of significance within democratic regimes. 
The estimated support with the expanded data is not significant in GMM models.

Using the same models and the measurement, the support estimate from a more qualified data yields insignificant results. 
This undermines the reliability of significant results from the estimate using the original data.^[In fact, when we further improve the estimate and reduce the uncertainty by applying a more superior measurement model, the relationship between public support and democratic survival disappears.] 

At the same time, the results also shows that ignoring uncertainty may lead to misestimation of the point effect as well. 
In the case here, the point estimates of democracy support are notably larger than the original estimate for both model settings. 
We draw variable values from their distributions and estimate the coefficient first before combining through Rubin's rule.
The deviation of the result from the original one indicates the coefficient (point) estimates were not that consistent.
In other words, the estimates based on the mean values of variables cannot fully reflect their characteristics and relations at all.
Only when the uncertainty is accounted, their effect can be more properly estimated.


```{r pointAJPS, eval=TRUE}
ls_iv <- c("plm::lag(SupDem_trim, 1)",
           "plm::lag(SupDem_Democ, 1) + plm::lag(SupDem_Autoc, 1)")

ls_method <- c("plm", "pgmm")

ls_eq <- glue("Libdem_VD ~ plm::lag(Libdem_VD, 1:2) + {ls_iv} + plm::lag(lnGDP_imp, 1) + plm::lag(GDP_imp_grth, 1) + plm::lag(Libdem_regUN, 1) + plm::lag(Pr_Muslim, 1) + plm::lag(Res_cp_WDI_di, 1)") 

ls_mod <- c(
  glue("plm({ls_eq}, model = 'pooling', data = sd.plm)"),
  glue(
    "pgmm({ls_eq} | plm::lag(Libdem_VD, 3:5), data = sd.plm, effect='individual', model='onestep', transformation='ld', indexes=c('Country', 'Year'))"
  )
)

df_result_cls <- map(ls_mod, function(mod) {
  result <- eval(parse(text = mod))
})

tidy_cls <- map(df_result_cls, function(result) {
  df_result <- tidy(result, conf.int = TRUE)
  
  if (class(result) == "plm") {
     mutate(df_result, std.error = vcovBK_se(result))
  } else{
    mutate(df_result, std.error = vcovHC_se(result))
  }
  
})

glance_cls <- map(df_result_cls, function(aResult){
  if(class(aResult) == "plm"){ 
    glance.plm(aResult) # using the customized glance function
  }else{
      glance(aResult)
    }
})

result_clsAJPS <- map2(tidy_cls, glance_cls, ~ list(.x, .y))
names(result_clsAJPS) <- c("pooled", "pooled-regime", "gmm", "gmm-regime")

saveRDS(result_clsAJPS, file = here::here("output", "estimates_clsMeanAJPS.RDS"))  
```

```{r model-AJPS}

#ls_iv <- c("plm::lag(theta, 1)", 
#    "plm::lag(theta_dem, 1) + plm::lag(theta_aut, 1) ") 

ls_iv <- c("plm::lag(SupDem_trim, 1)", 
    "plm::lag(theta_dem_trim, 1) + plm::lag(theta_aut_trim, 1) ") #use trimmed data

ls_method <- c("plm", "pgmm")

ls_eq <- glue("Libdem_VD ~ plm::lag(Libdem_VD, 1:2) + {ls_iv} + plm::lag(lnGDP_imp, 1) + plm::lag(GDP_imp_grth, 1) + plm::lag(Libdem_regUN, 1) + plm::lag(Pr_Muslim, 1) + plm::lag(Res_cp_WDI_di, 1)") 

ls_mod_ajpsCLS <- c(
    glue("plm({ls_eq}, model = 'pooling', data = aData)"),
    glue(
        "pgmm({ls_eq} | plm::lag(Libdem_VD, 3:5), data = aData, effect='individual', model='onestep', transformation='ld', indexes=c('country', 'year'))"
    )
)

```

```{r result-pureAJPS}
result_pureAJPS <- map(ls_mod_ajpsCLS, function(aMod){ # reading a model
  result <- map(pure_cls_ajps, function(aData){ # applying to the 1000 datasets
    eval(parse(text = aMod))
  })
  
  result_betas <- mitools::MIextract(result, fun = coef)
  
  ## Not work with ifelse
  if(class(result[[1]])[1] == "plm"){
      result_vars <- mitools::MIextract(result, fun = vcovBK_se)
  }else{
      result_vars <- mitools::MIextract(result, fun = vcovHC_se)
  }
  
  
  tidy_clsUncertain <- summary(mitools::MIcombine(results = result_betas, 
                             variance = result_vars)) %>% 
    rownames_to_column(var = "term") %>%
        rename(conf.low = `(lower`,
               conf.high = `upper)`,
               estimate = results) %>%
        filter(!str_detect(term, "(Intercept)"))
  
  if(class(result[[1]]) == "plm"){ 
    glance_clsUncertain <- glance.plm(result[[1]]) # using the customized glance function
  }else{
    glance_clsUncertain <- glance(result[[1]])
  }
  
  result_apsrAJPS <- list(tidy_clsUncertain, glance_clsUncertain)
})

names(result_pureAJPS) <- c("pooled", "pooled-regime", "gmm", "gmm-regime")
   
saveRDS(result_pureAJPS, file = here::here("output", "estimates_clsPureAJPS.RDS"))
```

```{r result-expAJPS}
result_expAJPS <- map(ls_mod_ajpsCLS, function(aMod){ # reading a model
  result <- map(exp_cls_ajps, function(aData){ # applying to the 1000 datasets
    eval(parse(text = aMod))
  })
  
  result_betas <- mitools::MIextract(result, fun = coef)
  
  ## Not work with ifelse
  if(class(result[[1]])[1] == "plm"){
      result_vars <- mitools::MIextract(result, fun = vcovBK_se)
  }else{
      result_vars <- mitools::MIextract(result, fun = vcovHC_se)
  }
  
  
  tidy_dcpoUncertain <- summary(mitools::MIcombine(results = result_betas, 
                             variance = result_vars)) %>% 
    rownames_to_column(var = "term") %>%
        rename(conf.low = `(lower`,
               conf.high = `upper)`,
               estimate = results) %>%
        filter(!str_detect(term, "(Intercept)"))
  
  if(class(result[[1]]) == "plm"){ 
    glance_dcpoUncertain <- glance.plm(result[[1]]) # using the customized glance function
  }else{
    glance_dcpoUncertain <- glance(result[[1]])
  }
  
  result_expAJPS <- list(tidy_dcpoUncertain, glance_dcpoUncertain)
})

names(result_expAJPS) <- c("pooled", "pooled-regime", "gmm", "gmm-regime")

saveRDS(result_expAJPS, file = here::here("output", "estimates_clsExpAJPS.RDS"))
```

```{r coefName-AJPS, eval=TRUE}
index_coefName <- c(
  `plm::lag(Libdem_VD, 1:2)1` = "Democracy[t-1]",
  `plm::lag(Libdem_VD, 1:2)2` = "Democracy[t-2]",
  `plm::lag(Vdem_libdem, 1:2)1` = "Democracy[t-1]",
  `plm::lag(Vdem_libdem, 1:2)2` = "Democracy[t-2]",
  `plm::lag(SupDem_trim, 1)` = "Support[t-1]",
  `plm::lag(theta, 1)` = "Support[t-1]",
  `plm::lag(SupDem_Democ, 1)` = "Support[t-1](demo~only)",
  `plm::lag(SupDem_Autoc, 1)` = "Support[t-1](auto~only)",
  `plm::lag(theta_dem_trim, 1)` = "Support[t-1](demo~only)",
  `plm::lag(theta_aut_trim, 1)` = "Support[t-1](auto~only)",
  `plm::lag(lnGDP_imp, 1)` = "Log~GDP~per~capita[t-1]",
  `plm::lag(lg_imp_mdpgdp, 1)` = "Log~GDP~per~capita[t-1]",
  `plm::lag(GDP_imp_grth, 1)` = "GDP~per~capita~growth[t-1]",
  `plm::lag(mdprgdp_grwth, 1)` = "GDP~per~capita~growth[t-1]",
  `plm::lag(Libdem_regUN, 1)` = "Regional~democracy[t-1]",
  `plm::lag(Region_libdem, 1)` = "Regional~democracy[t-1]",
  `plm::lag(Pr_Muslim, 1)` = "Percent~Muslim[t-1]",
  `plm::lag(muslism_prop_2010, 1)` = "Percent~Muslim[t-1]",
  `plm::lag(Res_cp_WDI_di, 1)` = "Resource~dependence[t-1]",
  `plm::lag(dependence_pc_di, 1)` = "Resource~dependence[t-1]"
)
```

```{r plot-mainAJPS, fig.cap= "The Effect of Public Support on Democracy with Uncertainty", fig.width=7, fig.height=10, fig.align='center', eval=TRUE}

type_model <-
  c("Original", "Uncertainty", "Uncertainty+Expanded Data")

result_ajpsPooled <-
  list(result_clsAJPS,
       result_pureAJPS,
       result_expAJPS) %>%
  map2_df(type_model, ~ {
    .x$pooled[[1]] %>%
      filter(term != "(Intercept)") %>%
      select(term, estimate, conf.low, conf.high) %>%
      mutate(model = .y)
  }) %>% 
  mutate(type = "Pooled")

result_ajpsRegime <-
  list(result_clsAJPS,
       result_pureAJPS,
       result_expAJPS) %>%
  map2_df(type_model, ~ {
    .x$`pooled-regime`[[1]] %>%
      filter(term != "(Intercept)") %>%
      select(term, estimate, conf.low, conf.high) %>%
      mutate(model = .y)
  }) %>% 
  mutate(type = "Regime Specified")

df_plot <- bind_rows(result_ajpsPooled, result_ajpsRegime) %>% 
    mutate(term = index_coefName[term],
           term = factor(term, levels = unique(index_coefName)))
 
dwplot(df_plot) +
    geom_vline(xintercept = 0,
               colour = "grey80",
               linetype = 2) +
    theme_minimal() +
    ggtitle("DV: Liberal Democracy (Vdem)") +
    xlab("Coefficient Estimate") +
    theme(
        axis.title.y = element_blank(),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    scale_y_discrete(labels = parse(text = rev(levels(df_plot$term)))) +
    # Using expressions of underscore and greek letters
    # scale_color_gb(palette = "digitMixed") +
    facet_wrap(~ type)

```

The importance of accounting for the measurement uncertainty appear more evident when the relevant variable plays as the outcome variable. 
In Figure \@ref(fig:plot-mainAPSR), we examine the thermostatic model of democratic support per @Claassen2020b [p. 47, Models 1.1 and 1.2]. 
The negative coefficient estimates of change in liberal democracy in the top set of results, which do not take uncertainty into account, imply that democratic mood decreases as democracy increases and vice versa. 
However, the middle and bottom results demonstrate that this thermostatic effect, too, does not hold after the measurement uncertainty is accounted for. 
And again, we observe the point estimates slides to the zero line.

[A discussion about the support t-1]

```{r pointAPSR, eval=TRUE}
load(here::here("data", "dem_mood_apsr.RData"))
sd.plm <- pdata.frame(x, index = c("Country", "Year")) 

ls_ivECM <- c("diff(Libdem_z, lag = 1) + plm::lag(Libdem_z, 1)", 
              "diff(Polyarchy_z, lag = 1) + plm::lag(Polyarchy_z, 1) + diff(Liberal_z, lag = 1) + plm::lag(Liberal_z, 1)")
ls_ctrlECM <- c("", " + diff(Corrup_TI_z, lag = 1) + plm::lag(Corrup_TI_z, 1)")

ls_eqECM <- glue("diff(SupDem_trim, lag = 1) ~ plm::lag(SupDem_trim, 1:2) + {ls_ivECM} + diff(lnGDP_imp, lag = 1) + plm::lag(lnGDP_imp, 1)") %>% 
  outer(ls_ctrlECM, paste0) %>% 
  as.vector()

ls_ivFD <- c("Libdem_z",
             "Polyarchy_z + Liberal_z")

ls_ctrlFD <- c("", " + Corrup_TI_z")

ls_eqFD <- glue("SupDem_trim ~ {ls_ivFD} + lnGDP_imp") %>% 
  outer(ls_ctrlFD, paste0) %>% 
  as.vector()

ls_mod <- c(
  glue("plm({ls_eqECM}, model = 'pooling', data = sd.plm)"),
  glue("plm({ls_eqFD}, model = 'fd', index = 'Country', data = sd.plm)")
)

df_result_clsAPSR <- map(ls_mod, function(mod) {
  result <- eval(parse(text = mod))
})

result_clsAPSR <- map(df_result_clsAPSR, function(aResult) {
  tidy_result <- tidy(aResult, conf.int = TRUE) %>% 
    mutate(std.error = vcovHC_se(aResult))
  
  glance_result <- glance.plm(aResult)
  
  ls_result <- list(tidy_result, glance_result)
})

names(result_clsAPSR) <- c("pooled1", "pooled-regime1", "pooled2", "pooled-regime2", 
                           "fd1", "fd-regime1", "fd2", "fd-regime2")

saveRDS(result_clsAPSR, file = here("output", "estimates_clsMeanAPSR.RDS"))
```

```{r model-APSR}
ls_ivECM <- c("diff(Libdem_z, lag = 1) + plm::lag(Libdem_z, 1)", 
              "diff(Polyarchy_z, lag = 1) + plm::lag(Polyarchy_z, 1) + diff(Liberal_z, lag = 1) + plm::lag(Liberal_z, 1)")
ls_ctrlECM <- c("", " + diff(Corrup_TI_z, lag = 1) + plm::lag(Corrup_TI_z, 1)")

ls_eqECM <- glue("diff(SupDem_trim, lag = 1) ~ plm::lag(SupDem_trim, 1:2) + {ls_ivECM} + diff(lnGDP_imp, lag = 1) + plm::lag(lnGDP_imp, 1)") %>% 
  outer(ls_ctrlECM, paste0) %>% 
  as.vector()

ls_ivFD <- c("Libdem_z",
             "Polyarchy_z + Liberal_z")

ls_ctrlFD <- c("", " + Corrup_TI_z")

ls_eqFD <- glue("diff(SupDem_trim, lag = 1) ~ {ls_ivFD} + lnGDP_imp") %>% 
  outer(ls_ctrlFD, paste0) %>% 
  as.vector()

ls_mod_apsrCLS <- c(
  glue("plm({ls_eqECM}, model = 'pooling', data = aData)"),
  glue("plm({ls_eqFD}, model = 'fd', index = 'country', data = aData)")
)
```

```{r result-pureAPSR}
result_pureAPSR <- map(ls_mod_apsrCLS, function(aMod){ # reading a model
  result <- map(pure_cls_apsr, function(aData){ # applying to the 900 datasets
    eval(parse(text = aMod))
  })
  
  result_betas <- mitools::MIextract(result, fun = coef)
  
  result_vars <- mitools::MIextract(result, fun = vcovHC_se)
  
  tidy_clsUncertainAPSR <- summary(mitools::MIcombine(results = result_betas, 
                             variance = result_vars)) %>% 
    rownames_to_column(var = "term") %>%
        rename(conf.low = `(lower`,
               conf.high = `upper)`,
               estimate = results) %>%
        filter(!str_detect(term, "(Intercept)"))
  
  glance_clsUncertainAPSR <- glance.plm(result[[1]])
  
  result_apsrAJPSAPSR <- list(tidy_clsUncertainAPSR, glance_clsUncertainAPSR)
})

names(result_pureAPSR) <- c("pooled1", "pooled-regime1", "pooled2", "pooled-regime2", "fd1", "fd-regime1", "fd2", "fd-regime2")

saveRDS(result_pureAPSR, file = here("output", "estimates_clsPureAPSR.RDS"))
```

```{r result-expAPSR}
result_expAPSR <- map(ls_mod_apsrCLS, function(aMod){ # reading a model
  result <- map(exp_cls_apsr, function(aData){ # applying to the 1000 datasets
    eval(parse(text = aMod))
  })
  
  result_betas <- mitools::MIextract(result, fun = coef)
  
  result_vars <- mitools::MIextract(result, fun = vcovHC_se)
  
  tidy_dcpoUncertainAPSR <- summary(mitools::MIcombine(results = result_betas, 
                             variance = result_vars)) %>% 
    rownames_to_column(var = "term") %>%
        rename(conf.low = `(lower`,
               conf.high = `upper)`,
               estimate = results) %>%
        filter(!str_detect(term, "(Intercept)"))
  
  glance_dcpoUncertainAPSR <- glance.plm(result[[1]])
  
  result_expAPSR <- list(tidy_dcpoUncertainAPSR, glance_dcpoUncertainAPSR)
})

names(result_expAPSR) <- c("pooled1", "pooled-regime1", "pooled2", "pooled-regime2",  "fd1", "fd-regime1", "fd2", "fd-regime2")

saveRDS(result_expAPSR, file = here("output", "estimates_clsExpAPSR.RDS"))
```

```{r coefName-APSR, eval=TRUE}
index_coefName <- c(
    `plm::lag(SupDem_trim, 1:2)1` = "Support[t-1]",
    `plm::lag(SupDem_trim, 1:2)2` = "Support[t-2]",
    `plm::lag(theta_trim, 1:2)1` = "Support[t-1]",
    `plm::lag(theta_trim, 1:2)2` = "Support[t-2]",
    
    `diff(Libdem_z, lag = 1)` = "Delta~Liberal~democracy",
    `diff(Vdem_libdem_z, lag = 1)` = "Delta~Liberal~democracy",
    `plm::lag(Libdem_z, 1)` = "Liberal~democracy[t-1]",
    `plm::lag(Vdem_libdem_z, 1)` = "Liberal~democracy[t-1]",
    
    `diff(Liberal_z, lag = 1)` = "Delta~Electoral~democracy",
    `diff(Vdem_liberal_z, lag = 1)` = "Delta~Electoral~democracy",
    `plm::lag(Liberal_z, 1)` = "Electoral~democracy[t-1]",
    `plm::lag(Vdem_liberal_z, 1)` = "Electoral~democracy[t-1]",
    
    `diff(Polyarchy_z, lag = 1)` = "Delta~Minoritarian~democracy",
    `diff(Vdem_polyarchy_z, lag = 1)` = "Delta~Minoritarian~democracy",
    `plm::lag(Polyarchy_z, 1)` = "Minoritarian~democracy[t-1]",
    `plm::lag(Vdem_polyarchy_z, 1)` = "Minoritarian~democracy[t-1]",
    
    `diff(lnGDP_imp, lag = 1)` = "Delta~Log~GDP~per~capita",
    `diff(lg_imp_mdpgdp, lag = 1)` = "Delta~Log~GDP~per~capita",
    `plm::lag(lnGDP_imp, 1)` = "Log~GDP[t-1]",
    `plm::lag(lg_imp_mdpgdp, 1)` = "Log~GDP[t-1]"
    # `diff(Corrup_TI_z, lag = 1)`= "Delta~Corruption",
    # `plm::lag(Corrup_TI_z, 1)` = "Log~Corruption[t-1]",
    # `Corrup_TI_z` = "Log~Corruption[t-1]"
)
```

```{r plot-mainAPSR, fig.cap= "The Effect of Democracy on the Change of Public Support", fig.width=7, fig.height=10, eval = TRUE}
result_clsAPSR <- readRDS(here("output", "estimates_clsMeanAPSR.RDS"))
result_pureAPSR <- readRDS(here("output", "estimates_clsFullUncertainAPSR.RDS"))
result_expAPSR <- readRDS(here("output", "estimates_clsExpAPSR.RDS"))

type_model <-
  c("Original", "Uncertainty", "Uncertainty+Expanded Data")

result_apsrPooled <-
  list(result_clsAPSR,
       result_pureAPSR,
       result_expAPSR) %>%
  map2_df(type_model, ~ {
    .x$pooled1[[1]] %>%
      filter(term != "(Intercept)") %>%
      select(term, estimate, conf.low, conf.high) %>%
      mutate(model = .y)
  }) %>% 
  mutate(type = "Pooled")

result_apsrRegime <-
  list(result_clsAPSR,
       result_pureAPSR,
       result_expAPSR) %>%
  map2_df(type_model, ~ {
    .x$`pooled-regime1`[[1]] %>%
      filter(term != "(Intercept)") %>%
      select(term, estimate, conf.low, conf.high) %>%
      mutate(model = .y)
  }) %>% 
  mutate(type = "Institution Specified")

df_plot <- bind_rows(result_apsrPooled, result_apsrRegime) %>% 
    mutate(term = index_coefName[term],
           term = factor(term, levels = unique(index_coefName)), 
           type = factor(type, levels = c("Pooled", "Institution Specified")))
 
dwplot(df_plot) +
    geom_vline(xintercept = 0,
               colour = "grey80",
               linetype = 2) +
    ggtitle("DV: The Change of Public Support for Democracy") +
    xlab("Coefficient Estimate") +
    theme(
        axis.title.y = element_blank(),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    facet_wrap( ~ type) + 
    scale_y_discrete(labels = parse(text = rev(levels(df_plot$term))))
    # Using expressions of underscore and greek letters
    # scale_color_gb(palette = "digitMixed")
    


```

# Discussion

In short, the conclusions of Claassen [-@Claassen2020a; -@Claassen2020b] that public support has a positive effect on democracy and democracy a negative effect on support are not empirically supported once measurement uncertainty is taken into account, even when more data are used.

There are several potential methodological explanations for these null results.
One issue is that the survey items employed---which ask respondents to assess the desirability or appropriateness of democracy, to compare democracy to some undemocratic alternative, or to assess one of these alternatives---may not capture every aspect of democratic support necessary for it to play its hypothesized roles in the classic theory.
If only those who profess to prefer democracy to its alternatives _and also_ value freedom of expression, freedom of association, and pluralism of opinion will take appropriate action when democracy is threatened, then this measure is inadequate to its purpose [see, e.g., @Schedler2007].
Moreover, given the multi-faceted nature of democratic attitudes, even the inclusion of such questions in unidimensional public opinion models such as those provided by @Claassen2019 or @Solt2020a are unlikely to be sufficient [see, e.g., @Wuttke2020].
Another issue is that even if these survey questions do capture support for the generic concept of democracy, these measurement models might still be incapable of suitably capturing democratic support due to the variation in understanding the concept across countries or over time within countries [@Wuttke2021]. 
Yet another is that this measure provides no assessment of the _relative_ importance the public affords democracy.
It provides no information on the extent to which other values, such as policy preferences or partisanship, weigh more heavily---and there is growing evidence that, at least in the United States, there are many for whom these other considerations excuse substantial transgressions against democracy [see @bartels_ethnic_2020; @Carey2020; @graham_democracy_2020; @McCoy2020]. 

There are theoretical explanations for the null results as well.
With regard to how levels of democracy affect public support, we note that even the proponents of the classic argument did not contend that the mere existence of democratic institutions, no matter how consistently feckless and ineffective, would generate support among the public: instead, they maintained, public support would be gained through experience with government performance that was generally effective [@lipset_social_1959, 86-89; @Easton1965, 119-120].
There is some empirical support for this, with government effectiveness positively related to public support among democracies and negatively related in non-democracies [@Magalhaes2014]. 
The finding of @Krieckhaus2014 that income inequality is strongly negatively related to public support in democracies suggests that performance regarding redistribution is particularly important.
Relatedly, on the reverse part of the classic argument, @Qi2011 suggests that democratic support alone cannot be expected to generate democratic change and oppose backsliding.
Instead, that work contends, it is the combination of democratic support and dissatisfaction with current regime performance that generates demand for greater democracy.
The effects of public support also have cultural-bound.
@Brunkert2019 contends outspoken support for democracy is a "deceptive indicator of public's affinity to democracy" [423] and finds public support has neither pro-democratic nor anti-authoritarian effect without controlling emancipative values.
Empirical results show that the meaning of support for democracy is dependent on emancipation values and is reversed to its own negation in a society with weak emancipative values [see, e.g.,@Kirsch2019, 83-85].
And we must be open to the possibility that no theoretical elaboration, no respecification of these models will reveal relationships between public opinion and democracy.
Democratic backsliding may simply be primarily a matter of elite decisionmaking [see, e.g., @levitsky_how_2018].
Regardless, these explanations indicate that there remains much work to be done in the empirical study of public support and democracy.


# Conclusion

In this letter, we reexamined the findings from Claassen [-@Claassen2020a; -@Claassen2020b], two articles that maintain that public support helps the survival of democracy and democratic development has a thermostatic effect on public support.
We demonstrated the importance of incorporating measurement uncertainty in analyzing the relationship between public support and democracy.
Taking uncertainty into account rendered both articles' conclusions without empirical support, even when we added considerable more data.

This points to the absolute necessity of incorporating measurement uncertainty into analyses that include latent variables.
Measurement issues have never had a prominent place in comparative political studies because they need more time to estimate models, but they ground the quality of data and the basis of analysis [@stegmueller2011, 484].
As the use of latent variables grows more common in political science, both researchers and readers should be aware that these variables' concomitant measurement uncertainty cannot be neglected.

The null results reached in this letter could arise from several sources.
We identified a number of potential shortcomings in the measurement of democratic support and ways in which the analysis models might be underspecified.
All of these could and should be explored in future research, though there are also theoretically grounded reasons to suspect that the relationships are in fact negligible.
In any event, the sanguine assessment that readers may draw from Claassen [-@Claassen2020a; -@Claassen2020b]---that the fate of democracies depend on public support, and when eroded, their publics will rally to them---is not supported by the current evidence.
Those who would defend democracy have no grounds to be complacent.


# References  {-}

<div id = 'refs'></div>

\pagebreak

# Online Supplementary Materials {-}
# (APPENDIX) Appendix {-}
# Numeric Results for Replicating Claassen 2020a

```{r num-labelAJPS, eval=TRUE}
names_coef <- c(
  "(Intercept)" = "(Intercept)",
  "plm::lag(Libdem_VD, 1:2)1" = "Democracy[t-1]",
  "plm::lag(Libdem_VD, 1:2)2"  = "Democracy[t-2]",
  "plm::lag(SupDem_trim, 1)" = "Support[t-1]",
  "plm::lag(SupDem_Democ, 1)" = "Support in Democracy",
  "plm::lag(SupDem_Autoc, 1)" = "Support in Autocracy",
  "plm::lag(lnGDP_imp, 1)" = "Log~GDP~per~capita[t-1]",
  "plm::lag(GDP_imp_grth, 1)"  = "GDP~per~capita~growth[t-1]",
  "plm::lag(Libdem_regUN, 1)" = "Regional~democracy[t-1]",
  "plm::lag(Pr_Muslim, 1)" = "Percent~Muslim[t-1]",
  "plm::lag(Res_cp_WDI_di, 1)" = "Resource~dependence[t-1]"
)
```

```{r num-pointAJPS, results='asis', eval=TRUE}
tb_result_cls <- map(result_clsAJPS, ~ {
  names(.) <- c("tidy", "glance")
  class(.) <- "modelsummary_list"
  return(.)})

names(tb_result_cls) <- c("Pooled", "Pooled-Regime", 
                          "GMM", "GMM-Regime")

modelsummary(tb_result_cls,  
             statistic = "conf.int",
             coef_map = names_coef, 
             output = "latex", 
             title = "Original") %>%
  
  kableExtra::kable_styling(font_size = 8) %>% 
  kableExtra::kable_styling(latex_options = "HOLD_position")
```

```{r num-pureAJPS, results='asis', eval=TRUE}
tb_result_pureAJPS <- map(result_pureAJPS, ~ {
  names(.) <- c("tidy", "glance")
  class(.) <- "modelsummary_list"
  return(.)})

names(tb_result_cls) <- c("Pooled", "Pooled-Regime", 
                          "GMM", "GMM-Regime")

modelsummary(tb_result_pureAJPS, 
             statistic = "conf.int",
             coef_map = names_coef, 
             output = "latex", 
             title = "W. Uncertainty") %>% 
  kableExtra::kable_styling(latex_options = "HOLD_position")
```

```{r num-expAJPS, results='asis', eval=TRUE}
tb_result_expAJPS <- map(result_expAJPS, ~ {
  names(.) <- c("tidy", "glance")
  class(.) <- "modelsummary_list"
  return(.)})

names(tb_result_expAJPS) <- c("Pooled", "Pooled-Regime", 
                          "GMM", "GMM-Regime")

modelsummary(tb_result_expAJPS, 
             statistic = "conf.int",
             coef_map = names_coef, 
             output = "latex", 
             title = "W. Uncertainty") %>% 
  kableExtra::kable_styling(latex_options = "HOLD_position")
```

\blandscape

# Numeric Results for Replicating Claassen 2020b

```{r num-labelAPSR, eval=TRUE}
names_coef <- c(
  "(Intercept)" = "(Intercept)",
  "plm::lag(SupDem_trim, 1:2)1" = "Democratic\n Mood\n (t-1)",
  "plm::lag(SupDem_trim, 1:2)2" = "Democratic\n Mood\n (t-2)",
  "diff(Libdem_z, lag = 1)" = "Liberal\n Democracy\n (Difference)",
  "Libdem_z" = "Liberal\n Democracy\n (Difference)",
  "plm::lag(Libdem_z, 1)" = "Liberal\n Democracy\n (t-1)",
  "diff(Polyarchy_z, lag = 1)" = "Electoral\n Democracy\n (Difference)",
  "Polyarchy_z" = "Electoral\n Democracy\n (Difference)",
  "plm::lag(Polyarchy_z, 1)" = "Electoral\n Democracy\n (t-1)",
  "diff(Liberal_z, lag = 1)" = "Minoritarian\n Democracy\n (Difference)",
  "Liberal_z" = "Minoritarian\n Democracy\n (Difference)",
  "plm::lag(Liberal_z, 1)" = "Minoritarian\n Democracy\n (t-1)",
  "diff(lnGDP_imp, lag = 1)" = "Log GDP\n per capita\n (Difference)",
  "lnGDP_imp" = "Log GDP\n per capita\n (Difference)",
  "plm::lag(lnGDP_imp, 1)" = "Log GDP\n (t-1)",
  "diff(Corrup_TI_z, lag = 1)" = "Corruption\n (Difference)",
  "Corrup_TI_z" = "Corruption\n (Difference)",
  "plm::lag(Corrup_TI_z, 1)" = "Corruption\n (t-1)"
)
```

```{r num-pointAPSR, results='asis', eval=TRUE}
tb_result_clsAPSR <- map(result_clsAPSR, ~ {
  names(.) <- c("tidy", "glance")
  class(.) <- "modelsummary_list"
  return(.)}) %>% 
  .[c("pooled1", "pooled-regime1", "fd1", "fd-regime1",
      "pooled2", "pooled-regime2", "fd2", "fd-regime2")]

names(tb_result_clsAPSR) <- c("ECM", "ECM-Regime", "FD", "FD-Regime","ECM Corrup", "ECM Corrup-Regime", "FD Corrup", "FD Corrup-Regime")

modelsummary(tb_result_clsAPSR, 
             stars = TRUE,
             coef_map = names_coef, 
             output = "latex") %>% 
  kableExtra::kable_styling(font_size = 7) %>% 
  kableExtra::kable_styling(latex_options = "HOLD_position")
```

\elandscape

\blandscape

```{r num-pureAPSR, results='asis', eval=TRUE}
tb_result_pureAPSR <- map(result_pureAPSR, ~ {
  names(.) <- c("tidy", "glance")
  class(.) <- "modelsummary_list"
  return(.)}) %>% 
  .[c("pooled1", "pooled-regime1", "fd1", "fd-regime1",
      "pooled2", "pooled-regime2", "fd2", "fd-regime2")]

names(tb_result_pureAPSR) <- c("ECM", "ECM-Regime", "FD", "FD-Regime","ECM Corrup", "ECM Corrup-Regime", "FD Corrup", "FD Corrup-Regime")


modelsummary(tb_result_pureAPSR, 
             statistic = "conf.int",
             coef_map = names_coef, 
             output = "latex") %>% 
  kableExtra::kable_styling(font_size = 7) %>% 
  kableExtra::kable_styling(latex_options = "HOLD_position")
```

\elandscape

\blandscape

```{r num-expAPSR, results='asis', eval=TRUE}
tb_result_expAPSR <- map(result_expAPSR, ~ {
  names(.) <- c("tidy", "glance")
  class(.) <- "modelsummary_list"
  return(.)}) %>% 
  .[c("pooled1", "pooled-regime1", "fd1", "fd-regime1",
      "pooled2", "pooled-regime2", "fd2", "fd-regime2")]

names(tb_result_expAPSR) <- c("ECM", "ECM-Regime", "FD", "FD-Regime","ECM Corrup", "ECM Corrup-Regime", "FD Corrup", "FD Corrup-Regime")

modelsummary(tb_result_expAPSR, 
             statistic = "conf.int",
             coef_map = names_coef, 
             output = "latex") %>% 
  kableExtra::kable_styling(font_size = 7) %>% 
  kableExtra::kable_styling(latex_options = "HOLD_position")
```

\elandscape


# Replication with Alternative Methods Accounting for Uncertainty {#moc}

To ensure the robustness of our analysis, we apply another method to account for uncertainty.
The method we employ is "method of composition" (MOC).
It is a common method for Monte Carlo integration, but can also be applied for addressing uncertainty [@treier_democracy_2008].
To compare these two methods, let's denote `y` as a vector of the outcome variable [either institutional democracy in @Claassen2020a or the changes in mass support of democracy in @Claassen2020b]. 
Let $x$ (variables without subscript are used to denote vectors of observations, viz., $x$ = ($x_1$,......, $x_i$)) be a vector of the explanatory variable (e.g., mass support or institutional democracy) and $\theta$ be the parameter of interest.
In multiple overimputation (MO, the method used in the main article), the explanatory variable with measurement errors is regarded as missing data $x^{mis}$ with an observed proxy $w$ under the assumption of "Missing at Random" and "Ignorable Measurement Mechanism Assignment" [@Blackwell2017].
The explanatory variables without error are denoted $x^{obs}$.
*Personally, I think we should be careful to use MO since our approach is not MO. I will go back here later.* 
The parameter likelihood is then



\begin{equation}
\mathcal{L}(\theta|y, x^{obs}) \propto \int_{\chi} p(x|y, \theta)p(y|\theta)dx^{mis}.
\end{equation}


Given $x$ is unobservable, one can estimate it through the proxy $w$ together with the measurement error $a$:

\begin{equation}
E(w | x) = x + a.
\end{equation}

After gaining the parameter density based on the above functions, one can apply Rubin's Rule to combine the point estimates and standard errors into single values yet accounting for both within and between imputation variances [@Rubin1987].

MOC addresses the same issue from a slightly different angle.
The method assumes that the explanatory and outcome variables are samples from their estimate functions, and their paired sample follows a joint density [@Tanner1993, p.31].
From the joint density, one can decomposite the likelihood of the explanatory variable and its parameter to a product of their own probabilities.
When x is measured with errors $w$, the probability becomes conditional:

\begin{equation}
\mathcal{L}(\theta, x|y, w) = p(\theta|x,y)p(x|w).
\end{equation}

Based on this decomposition, one can estimate the marginal density for &\theta&:

\begin{equation}
\mathcal{L}(\theta|y, x) \propto \int_{\chi} p(\theta|y,x)p(x|w)dx.
\end{equation}

Again, the gained parameter density can be combined into single values.
A common way to do so is using the mean of $theta$ as the point estimate, and the variance from the density as the standard error.

```{r moc-estimates, eval=TRUE}


result_clsAJPS <- readRDS(here("output", "estimates_clsMeanAJPS.RDS"))
result_clsAPSR <- readRDS(here("output", "estimates_clsMeanAPSR.RDS"))
mocresult_pureAJPS <- readRDS(here("output", "estimates_moc_pureAJPS.RDS"))
mocresult_expAJPS <- readRDS(here("output", "estimates_moc_expAJPS.RDS"))
mocresult_pureAPSR <- readRDS(here("output", "estimates_moc_pureAPSR.RDS"))
mocresult_expAPSR <- readRDS(here("output", "estimates_moc_expAPSR.RDS"))

```

```{r mocresult-pureAJPS}

df_pure_clsAjps <- purrr::map(1:900, function(anEntry) {
  pure_cls_ajps[[anEntry]] %>% 
    plm::pdata.frame(index = c("country", "year"))
})

result_pure_clsUncertain  <- map(ls_mod_ajpsCLS[1:2], function(aMod){
  result <- methodComposition1(df_pure_clsAjps,aMod)
})

names(result_pure_clsUncertain) <- c("pooled", "pooled-regime")


result_pure_clsUncertain_gmm  <- map(ls_mod_ajpsCLS[3:4], function(aMod){
  result <- methodComposition2(df_pure_clsAjps,aMod)
})
names(result_pure_clsUncertain_gmm) <- c("gmm", "gmm-regime")

mocresult_pureAJPS <- append(result_pure_clsUncertain, result_pure_clsUncertain_gmm)


saveRDS(mocresult_pureAJPS, file =here("output","estimates_moc_pureAJPS.RDS"))


```

```{r mocresult-expAJPS}

df_exp_clsAjps <- purrr::map(1:900, function(anEntry) {
  exp_cls_ajps[[anEntry]] %>% 
    plm::pdata.frame(index = c("country", "year"))
})

result_exp_clsUncertain  <- map(ls_mod_ajpsCLS[1:2], function(aMod){
  result <- methodComposition1(df_exp_clsAjps,aMod)
})

names(result_exp_clsUncertain) <- c("pooled", "pooled-regime")

result_exp_clsUncertain_gmm  <- map(ls_mod_ajpsCLS[3:4], function(aMod){
  result <- methodComposition2(df_exp_clsAjps,aMod)
})
names(result_exp_clsUncertain_gmm) <- c("gmm", "gmm-regime")

mocresult_expAJPS <- append(result_exp_clsUncertain, result_exp_clsUncertain_gmm)

saveRDS(mocresult_expAJPS, file =here("output","estimates_moc_expAJPS.RDS")) 

```

```{r plot-mocAJPS, fig.cap= "The Effect of Public Support on Democracy ", eval = TRUE, fig.width=7, fig.height=10, eval=TRUE}

result_pooled <- bind_rows(
  mutate(result_clsAJPS[["pooled"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm(mocresult_pureAJPS[["pooled"]]), model = "Uncertainty"),
  mutate(MOCsumm(mocresult_expAJPS[["pooled"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "Pooled")


result_gmm <- bind_rows(
  mutate(result_clsAJPS[["gmm"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm(mocresult_pureAJPS[["gmm"]]), model = "Uncertainty"),
  mutate(MOCsumm(mocresult_expAJPS[["gmm"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "GMM")


result_pooledAJPS <- bind_rows(result_pooled, result_gmm) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    term = rep(
      c("Democracy\n (t-1)",
        "Democracy\n (t-2)",
        "Support\n (t-1)",
        "Log GDP\n per capita\n (t-1)",
        "GDP per\n capita growth\n (t-1)",
        "Regional\n democracy\n (t-1)",
        "Percent\n Muslim\n (t-1)",
        "Resource\n dependence\n (t-1)"),
      time = 6), 
    type = factor(type, levels = c("Pooled", "GMM")),
    model = factor(model, levels = c("Original", "Uncertainty", "Uncertainty+Expanded Data")))

terms <- factor(rev(c("Democracy[t-1]",
                      "Democracy[t-2]",
                      "Support[t-1]",
                      "Log~GDP~per~capita[t-1]",
                      "GDP~per~capita~growth[t-1]",
                      "Regional~democracy[t-1]",
                      "Percent~Muslim[t-1]",
                      "Resource~dependence[t-1]")), levels =
                  rev(c("Democracy[t-1]",
                        "Democracy[t-2]",
                        "Support[t-1]",
                        "Log~GDP~per~capita[t-1]",
                        "GDP~per~capita~growth[t-1]",
                        "Regional~democracy[t-1]",
                        "Percent~Muslim[t-1]",
                        "Resource~dependence[t-1]")))

plot_AJPS1 <- dwplot(result_pooledAJPS, dodge_size = 0.8, by_2sd = FALSE) +
  scale_y_discrete(labels = parse(text = levels(terms))) +
  scale_color_grey(start = 0.4, end = 0.8) +
  labs(
    title = "DV: V-Dem Liberal Democracy Index",
    subtitle = "Regime Compacted"
  ) +
  facet_wrap(~type, scales = "free_x") + 
  theme(legend.position = "none")

###########Regime
result_regime <- bind_rows(
  mutate(result_clsAJPS[["pooled-regime"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm(mocresult_pureAJPS[["pooled-regime"]]), model = "Uncertainty"),
  mutate(MOCsumm(mocresult_expAJPS[["pooled-regime"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "Pooled")

result_regimeGmm <- bind_rows(
  mutate(result_clsAJPS[["gmm-regime"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm(mocresult_pureAJPS[["gmm-regime"]]), model = "Uncertainty"),
 mutate(MOCsumm(mocresult_expAJPS[["gmm-regime"]]), model = "Uncertainty+Expanded Data")
)%>% 
  mutate(type = "GMM")

result_regimeAJPS <- bind_rows(result_regime, result_regimeGmm) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    term = rep(
      c("Democracy\n (t-1)",
        "Democracy\n (t-2)",
        "Support\n demo only\n (t-1)",
        "Support\n auto only\n (t-1)",
        "Log GDP\n per capita\n (t-1)",
        "GDP per\n capita growth\n (t-1)",
        "Regional\n democracy\n (t-1)",
        "Percent\n Muslim\n (t-1)",
        "Resource\n dependence\n (t-1)"),
      time = 6), 
    type = factor(type, levels = c("Pooled", "GMM")),
    model = factor(model, levels = c("Original","Uncertainty", "Uncertainty+Expanded Data")))
terms2 <- factor(rev(c("Democracy[t-1]",
                       "Democracy[t-2]",
                       "Support[t-1] (democracies~only)",
                       "Support[t-1] (autocracies~only)",
                       "Log~GDP~per~capita[t-1]",
                       "GDP~per~capita~growth[t-1]",
                       "Regional~democracy[t-1]",
                       "Percent~Muslim[t-1]",
                       "Resource~dependence[t-1]")), levels =
                   rev(c("Democracy[t-1]",
                         "Democracy[t-2]",
                         "Support[t-1] (democracies~only)",
                         "Support[t-1] (autocracies~only)",
                         "Log~GDP~per~capita[t-1]",
                         "GDP~per~capita~growth[t-1]",
                         "Regional~democracy[t-1]",
                         "Percent~Muslim[t-1]",
                         "Resource~dependence[t-1]")))
plot_AJPS2 <- dwplot(result_regimeAJPS, dodge_size = 0.8, by_2sd = FALSE) +
  scale_y_discrete(labels = parse(text = levels(terms2))) +
  scale_color_grey(start = 0.4, end = 0.8, guide = guide_legend(reverse = TRUE)) +
  labs(
    title = "",
    subtitle = "Regime Specific"
  ) +
  facet_wrap(~type, scales = "free_x") +
  theme(legend.position = "bottom", 
        legend.title = element_blank())
legend <- get_legend(plot_AJPS2)
plot_AJPS2 <- plot_AJPS2 + theme(legend.position = "none")
grid.arrange(plot_AJPS1, plot_AJPS2, legend, ncol = 1)
```

```{r mocresult-pureAPSR}

df_pure_clsAPSR <- purrr::map(1:900, function(anEntry) {
  pure_cls_apsr[[anEntry]] %>% 
    plm::pdata.frame(index = c("country", "year"))
}
)


mocresult_pureAPSR  <- map(ls_mod_apsrCLS, function(aMod){
  result <- methodComposition3(df_pure_clsAPSR,aMod)
})  

 
names(mocresult_pureAPSR) <- c("pooled1", "pooled-regime1", "pooled2", "pooled-regime2",
                                "fd1", "fd-regime1", "fd2", "fd-regime2")


saveRDS(mocresult_pureAPSR, file = here::here("ouput","estimates_moc_pureAPSR.RDS"))

```

```{r mocresult-expAPSR}

df_exp_clsAPSR <- purrr::map(1:900, function(anEntry) {
  exp_cls_apsr[[anEntry]] %>% 
    plm::pdata.frame(index = c("country", "year"))
}
)


mocresult_expAPSR <- map(ls_mod_apsrCLS, function(aMod){
  result <- methodComposition3(df_exp_clsAPSR,aMod)
})  


names(mocresult_expAPSR) <- c("pooled1", "pooled-regime1", "pooled2", "pooled-regime2",
                                "fd1", "fd-regime1", "fd2", "fd-regime2")

saveRDS(mocresult_expAPSR, file = here::here("ouput","estimates_moc_expAPSR.RDS"))

```

```{r plot-mocAPSR, fig.cap= "The Effect of Democracy on the Change of Public Support", eval = TRUE, fig.width=7, fig.height=10, eval=TRUE}

result_ecm1 <- bind_rows(
  mutate(result_clsAPSR[["pooled1"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["pooled1"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["pooled1"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "ECM")

result_fd1 <- bind_rows(
  mutate(result_clsAPSR[["fd1"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["fd1"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["fd1"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "First Difference")

result_APSR1 <- bind_rows(result_ecm1, result_fd1) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    term = c(rep(
      c("Democratic Mood\n (t-1)",
        "Democratic Mood\n (t-2)",
        "Liberal Democracy\n (Difference)",
        "Liberal Democracy\n (t-1)",
        "Log GDP\n per capita\n (Difference)",
        "Log GDP\n (t-1)"),
      time = 3),
      rep(
        c("Liberal Democracy\n (Difference)", 
          "Log GDP\n per capita\n (Difference)"), 
        time = 3
      )),
    type = factor(type,  levels = c("ECM", "First Difference")),
    model = factor(model, levels = c("Original","Uncertainty", "Uncertainty+Expanded Data"))
  )

terms1 <- factor(rev(c("Support[t-1]",
                       "Support[t-2]",
                       "Delta~Liberal~democracy",
                       "Liberal~democracy[t-1]",
                       "Delta~Log~GDP~per~capita",
                       "Log~GDP[t-1]")),
                 levels = rev(c("Support[t-1]",
                                "Support[t-2]",
                                "Delta~Liberal~democracy",
                                "Liberal~democracy[t-1]",
                                "Delta~Log~GDP~per~capita",
                                "Log~GDP[t-1]")))
plot_APSR1 <- dwplot(result_APSR1, dodge_size = 0.8, by_2sd = FALSE) +
  scale_y_discrete(labels = parse(text = levels(terms1))) +
  scale_color_grey(start = 0.4, end = 0.8, guide = guide_legend(reverse = TRUE)) +
  # scale_color_uiowa(name = "", palette = "digitMixed") +
  labs(
    title = "DV: The Change of Public Support for Democracy",
    subtitle = "Regime Compacted"
  ) +
  facet_wrap(~type, drop=T,scales = "free_x") +
  theme(legend.position = "none")

############################ Regime specified####

result_ecmReg1 <- bind_rows(
  mutate(result_clsAPSR[["pooled-regime1"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["pooled-regime1"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["pooled-regime1"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "ECM")


result_fdReg1 <- bind_rows(
  mutate(result_clsAPSR[["fd-regime1"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["fd-regime1"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["fd-regime1"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "First Difference")


result_RegAPSR1 <- bind_rows(result_ecmReg1, result_fdReg1) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    term = c(rep(
      c("Democratic Mood\n (t-1)",
        "Democratic Mood\n (t-2)",
        "Electoral Democracy\n (Difference)",
        "Electoral Democracy\n (t-1)",
        "Minoritarian Democracy\n (Difference)",
        "Minoritarian Democracy\n (t-1)",
        "Log GDP\n per capita\n (Difference)",
        "Log GDP\n (t-1)"),
      time = 3),
      rep(
        c("Electoral Democracy\n (Difference)", 
          "Minoritarian Democracy\n (Difference)",
          "Log GDP\n per capita\n (Difference)"), 
        time = 3
      )),
    type = factor(type,  levels = c("ECM", "First Difference")),
    model = factor(model, levels = c("Original","Uncertainty", "Uncertainty+Expanded Data"))
  )
terms3 <- factor(rev(c("Support[t-1]",
                       "Support[t-2]",
                       "Delta~Electoral~democracy",
                       "Electoral~democracy[t-1]",
                       "Delta~Minoritarian~democracy",
                       "Minoritarian~democracy[t-1]",
                       "Delta~Log~GDP~per~capita",
                       "Log~GDP[t-1]")),
                 levels = rev(c("Support[t-1]",
                                "Support[t-2]",
                                "Delta~Electoral~democracy",
                                "Electoral~democracy[t-1]",
                                "Delta~Minoritarian~democracy",
                                "Minoritarian~democracy[t-1]",
                                "Delta~Log~GDP~per~capita",
                                "Log~GDP[t-1]")))
plot_RegAPSR1 <- dwplot(result_RegAPSR1, dodge_size = 0.8, by_2sd = FALSE) +
  scale_y_discrete(labels = parse(text = levels(terms3))) +
  scale_color_grey(start = 0.4, end = 0.8, guide = guide_legend(reverse = TRUE)) +
  # scale_color_uiowa(name = "", palette = "digitMixed") +
  labs(
    title = "",
    subtitle = "Regime Specified"
  ) +
  facet_wrap(~type, scales = "free_x") + 
  theme(legend.position = "none")


#########Corruption

result_ecm2 <- bind_rows(
  mutate(result_clsAPSR[["pooled2"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["pooled2"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["pooled2"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "ECM")



result_fd2 <- bind_rows(
  mutate(result_clsAPSR[["fd2"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["fd2"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["fd2"]]), model = "Uncertainty+Expanded Data")
) %>% 
  mutate(type = "First Difference")

result_APSR2 <- bind_rows(result_ecm2, result_fd2) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    term = c(rep(
      c("Democratic Mood\n (t-1)",
        "Democratic Mood\n (t-2)",
        "Liberal Democracy\n (Difference)",
        "Liberal Democracy\n (t-1)",
        "Log GDP\n per capita\n (Difference)",
        "Log GDP\n (t-1)",
        "Corruption\n (Difference)",
        "Corruption\n (t-1)"
      ),
      time = 3),
      rep(
        c("Liberal Democracy\n (Difference)", 
          "Log GDP\n per capita\n (Difference)",
          "Corruption\n (Difference)"), 
        time = 3
      )),
    type = factor(type,  levels = c("ECM", "First Difference")),
    model = factor(model, levels = c("Original","Uncertainty", "Uncertainty+Expanded Data"))
  )
terms2 <- factor(rev(c("Support[t-1]",
                       "Support[t-2]",
                       "Delta~Liberal~democracy",
                       "Liberal~democracy[t-1]",
                       "Delta~Log~GDP~per~capita",
                       "Log~GDP[t-1]",
                       "Delta~Corruption",
                       "Corruption[t-1]")),
                 levels = rev(c("Support[t-1]",
                                "Support[t-2]",
                                "Delta~Liberal~democracy",
                                "Liberal~democracy[t-1]",
                                "Delta~Log~GDP~per~capita",
                                "Log~GDP[t-1]",
                                "Delta~Corruption",
                                "Corruption[t-1]")))
plot_APSR2 <- dwplot(result_APSR2, dodge_size = 0.8, by_2sd = FALSE) +
  scale_y_discrete(labels = parse(text = levels(terms2))) +
  scale_color_grey(start = 0.4, end = 0.8, guide = guide_legend(reverse = TRUE)) +
  # scale_color_uiowa(name = "", palette = "digitMixed") +
  labs(
    title = "",
    subtitle = "W. Corruption"
  ) +
  facet_wrap(~type, scales = "free_x") +
  theme(legend.position = "none")


#########Regime + Corruption


result_ecmReg2 <- bind_rows(
  mutate(result_clsAPSR[["pooled-regime2"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["pooled-regime2"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["pooled-regime2"]]), model = "Uncertainty+Expanded Data")) %>% 
  mutate(type = "ECM")
  


result_fdReg2 <- bind_rows(
  mutate(result_clsAPSR[["fd-regime2"]][[1]][,1:3], model = "Original"),
  mutate(MOCsumm2(mocresult_pureAPSR[["fd-regime2"]]), model = "Uncertainty"),
  mutate(MOCsumm2(mocresult_expAPSR[["fd-regime2"]]), model = "Uncertainty+Expanded Data")) %>% 
  mutate(type = "First Difference")



result_RegAPSR2 <- bind_rows(result_ecmReg2, result_fdReg2) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    term = c(rep(
      c("Democratic Mood\n (t-1)",
        "Democratic Mood\n (t-2)",
        "Electoral Democracy\n (Difference)",
        "Electoral Democracy\n (t-1)",
        "Minoritarian Democracy\n (Difference)",
        "Minoritarian Democracy\n (t-1)",
        "Log GDP\n per capita\n (Difference)",
        "Log GDP\n (t-1)",
        "Corruption\n (Difference)",
        "Corruption\n (t-1)"
      ),
      time = 3),
      rep(
        c("Electoral Democracy\n (Difference)", 
          "Minoritarian Democracy\n (Difference)",
          "Log GDP\n per capita\n (Difference)",
          "Corruption\n (Difference)"), 
        time = 3
      )),
    type = factor(type,  levels = c("ECM", "First Difference")),
    model = factor(model, levels = c("Original","Uncertainty", "Uncertainty+Expanded Data"))
  )
terms4 <- factor(rev(c("Support[t-1]",
                       "Support[t-2]",
                       "Delta~Electoral~democracy",
                       "Electoral~democracy[t-1]",
                       "Delta~Minoritarian~democracy",
                       "Minoritarian~democracy[t-1]",
                       "Delta~Log~GDP",
                       "Log~GDP[t-1]",
                       "Delta~Corruption",
                       "Corruption[t-1]")),
                 levels = rev(c("Support[t-1]",
                                "Support[t-2]",
                                "Delta~Electoral~democracy",
                                "Electoral~democracy[t-1]",
                                "Delta~Minoritarian~democracy",
                                "Minoritarian~democracy[t-1]",
                                "Delta~Log~GDP",
                                "Log~GDP[t-1]",
                                "Delta~Corruption",
                                "Corruption[t-1]")))
plot_RegAPSR2 <- dwplot(result_RegAPSR2, dodge_size = 0.8, by_2sd = FALSE) +
  scale_y_discrete(labels = parse(text = levels(terms4))) +
  scale_color_grey(start = 0.4, end = 0.8, guide = guide_legend(reverse = TRUE)) +
  labs(
    title = "",
    subtitle = "Regime Specified w. Corruption"
  ) +
  facet_wrap(~type, scales = "free_x") +
  theme(legend.position = "bottom", 
        legend.title = element_blank())

legend <- get_legend(plot_RegAPSR2)

plot_RegAPSR2 <- plot_RegAPSR2 + theme(legend.position = "none")

grid.arrange(plot_APSR1, plot_APSR2, plot_RegAPSR1, plot_RegAPSR2, legend, ncol = 1)



```

Figure \@ref(fig:plot-mocAJPS) and \@ref(fig:plot-mocAPSR) presents the results of using MOC to engage measurement error. 
The results are consistent as we gained from the MO method (cf. Figure \@ref(fig:plot-mainAJPS) and \@ref(fig:plot-mainAPSR)).
